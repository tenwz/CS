# MySQL

## TODO

- [ ] 主从同步
- [ ] 组提交
- [ ] SQL优化
- [x] B树结构

## 一、索引

### B+树原理

#### 1. 数据结构

B Tree 指的是 Balance Tree，也就是平衡树。平衡树是一颗查找树，并且所有叶子节点位于同一层。

B+ Tree 是基于 B Tree 和叶子节点顺序访问指针进行实现，它具有 B Tree 的平衡性，并且通过顺序访问指针来提高区间查询的性能。

在 B+ Tree 中，一个节点中的 key 从

#### 2. 操作

进行查找操作时，首先在根节点进行二分查找，找到一个 key 所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行二分查找，找出 key 所对应的 data。



## 二、性能优化



## 三、切分





## 四、复制



## MySQL原理

- 锁

  - 粒度

    - 全局锁
      - （对整个数据库实例加锁）（逻辑备份（从库））	
      - -- MySQL 官方工具 mysqldump -single-transcation的原理是 启动一个事务进行备份，由于MVCC，此时数据是可以正常更新的（前提是引擎支持这个隔离级别）））
    - 表锁（开销小，加锁快，无死锁）
    - 行锁（开销大，加锁慢，有死锁）（TODO： 行锁最大并发数）
      - 意向锁（IS -> S , IX -> X）
        - 意向锁： 如果另一个任务试图在该表级别上应用共享或排它锁，则受到由第一个任务控制的表级别意向锁的阻塞。第二个任务在锁定该表前不必检查各个页或行锁，而只需检查表上的意向锁。
        - **case**： 事务A 锁住表 一行（只读） 事务 B 申请表的写锁。
      - 两阶段锁、逐行加锁、一级索引二级索引加锁方式
      - 死锁
        - 设置超时时间
        - 开启死锁检测
        - ？业务逻辑

  - 并发控制角度

    - 悲观锁
    - 乐观锁（场景）

  - 加锁范围角度

    - 幻读（当前读）

      - Record lock，索引记录锁，只锁对应的索引记录中的某个索引记录（无索引时锁表）
      - Gap lock，间隙锁，记录之前的间隙，RR隔离级别下避免幻读，间隙锁之间不冲突
      - Next key lock, 等于Record lock + Gap lock（索引记录前 是一个前开后闭的区间）

      

- 索引

  - 索引类型
    - 查找方式（哈希、有序数组、搜索树、跳表、LSM-tree）
    - 优点、缺点
    - InnoDB（主键索引、非主键索引）
  - B 树、TODO：页分裂和页合并
  - TODO：唯一索引和普通索引的区别

- 事务

  - 事务隔离级别

  - 脏读、不可重复读、幻读

  - MVCC （版本链、undolog、ReadVIew）

    - 快照读、当前读

    - 3 ： DB_row_id, DB_roll_ptr, DB_trx_id

    - 2 : DB_roll_ptr  -> undolog

    - 1 : ReadView 

      - m_ids
      - min_trx_id
      - max_trx_id(应该分配给下一个事务的id值)
      - creator_trx_id

      

- 持久化

  - crash-safe：读（在内存中？否则读磁盘，是则返回）写 -> 更新到内存 -> 写入redolog （prepare） A-> 写binlog B-> 提交事务（commit状态）       -> 回刷磁盘（异步）
    - A、B点发生崩溃的分析（两阶段提交（主从一致））
    - WAL 机制 -> 核心日志模块 -> 两阶段提交 -> ？组提交 -> 数据恢复流程
  - redolog
  - binlog

- 分布式

  - binlog 格式
  - 主从同步

哈希的<u>问题</u>：1. 哈希冲突（扩展 Java#Hash方法）2. 区间查询	（扩展 LSM-tree BitCask SSTable）
有序数组：1. 等值、范围查询（先二分到左边界，后右遍历）快。缺点：插入效率低（数组移动）、适用静态存储引擎。
？ 搜索树：N 叉树

InnoDB：主键索引（聚簇）（整行数据）（无定义主键情况）	非主键索引（二级索引）（主键的值（回表）（覆盖索引））

``` java
//MVCC 伪代码
ReadView rw;
 
if（trx_id == rw.creator_trx_id）{
    return true;
}
if(trx_id<rw.min_trx_id){
    return true;
}
if(trx_id>rw.max_trx_id){
    return false;
}
if(trx_id exist in rw.m_ids){
    return false;
}else{
    return true;
}
```

幻读：幻读是指当事务不是独立执行时发生的一种现象。（当前读）
事务A读取与搜索条件相匹配的若干行。事务B以插入或删除行等方式来修改事务A的结果集，然后再提交。
幻读是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，比如这种修改涉及到表中的“全部数据行”。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入“一行新数据”。那么，以后就会发生操作第一个事务的用户发现表中还存在没有修改的数据行，就好象发生了幻觉一样.一般解决幻读的方法是增加范围锁RangeS，锁定检索范围为只读，这样就避免了幻读。



## 数据库优化

- 索引	最左匹配规则（a b c）	覆盖索引	前缀索引	索引下推	区分度、查询率高
- explain 语句 TODO：行数预测，索引

## 设计原则

### 阿里泰山版

- 单表查询 VS 联表查询
  - 利于维护：复杂的关联查询，在修改时，基本等于推倒重来
  - 可复用性高：任何地方组装需要数据，不需要再次做相关查询，直接使用
  - 效率高：如果数据量上去，多表查询是笛卡尔乘积方式，需要检索的数据是几何倍上升的。另外多表查询索引设计上也考验开发者的功底，索引设计不合理，大数据量下的多表查询，很可能把数据库拖垮。
  - <u>**建议**</u>尽可能的使用单表查询+代码上组装的方式。使用Stream lambda + mybatis plus + lombok

外键

- 分库分表

## 场景

间隙锁的死锁：
间隙锁也并不是万能的，因为间隙锁导致同样的语句锁住更大的范围，其实影响了并发度，因此在某些情况下会造成死锁。比如下面的情况：

1. 判断断C=5是否存在；
2. 不存在就insert,存在就update；
3. 图中在并发的情况下，且c=5不存在，行锁无效，触发间隙锁，这时候事物2的insert需要等待事物1commit之后释放间隙锁。
4. 但是事物1，因为也insert导致了，不能释放锁就触发了死锁。

| 事务1                                   | 事务2                                       |
| :-------------------------------------- | :------------------------------------------ |
| begin transaction;                      | begin transaction;                          |
| select * from t where c=5 for update ;  |                                             |
| -                                       | select * from t where c=5 for share update; |
| -                                       | insert into t values(5,5);                  |
| insert into t values(5,5);（dead lock） | -                                           |

这种方式的解决方案，在满足业务的前提下，将事物的隔离级别改为RC，并且将binlog置为row。

（如果单看事务 1 ，临界锁实际上解决了重复检测的问题）

用读提交而不是可重复读：